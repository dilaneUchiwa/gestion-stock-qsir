**Diagramme de Séquence : Réception d'une Livraison (basée sur Commande, avec MàJ Stock)**

**Acteurs :** Utilisateur, Navigateur Web, Serveur Web (PHP)

**Composants :**
*   Navigateur Web
*   Routeur (`public/index.php`)
*   `DeliveryController.php`
*   `DeliveryModel.php` (Nom corrigé)
*   `PurchaseOrderModel.php`
*   `ProductModel.php`
*   `UnitModel.php`
*   `StockMovementModel.php` (utilisé par `ProductModel->updateStock()`)
*   `Database.php` (Classe Core)
*   Base de Données (PostgreSQL)
*   Vue (`procurement/deliveries/create.php`, `layouts/main.php`)
*   JavaScript (pour ajout dynamique d'items si livraison directe)

**Séquence :**

1.  **Utilisateur -> Navigateur Web :**
    *   Depuis une commande fournisseur (PO), clique sur "Recevoir les articles".
    *   Requête GET (ex: `index.php?url=delivery/create&po_id=123`).
    *   (Alternative : Navigue vers "Nouvelle Livraison Directe", requête GET `index.php?url=delivery/create`).

2.  **Navigateur Web -> Serveur Web (Routeur) :**
    *   Le Routeur appelle `DeliveryController::create()`.

3.  **Routeur -> `DeliveryController::create()` :**
    *   Récupère `po_id` (si présent).
    *   Charge les modèles nécessaires (`PurchaseOrderModel`, `ProductModel`, `UnitModel`, `SupplierModel`).
    *   Si `po_id` existe :
        *   Appelle `PurchaseOrderModel->getByIdWithItems($poId)` (qui joint les unités des items de PO).
        *   Appelle `getPendingPoItems()` pour calculer les quantités restantes à livrer pour chaque item de la PO (cette méthode utilise les `unit_id` et `quantity_ordered` de la PO).
    *   Appelle `ProductModel->getAll()` et `UnitModel->getAll()` pour les listes générales (pour livraison directe).
    *   Prépare `$productUnitsMap` pour les produits qui pourraient être ajoutés manuellement.
    *   Appelle `renderView('procurement/deliveries/create', $data)` avec toutes les données.

4.  **`DeliveryController` -> Vue (`procurement/deliveries/create.php`) :**
    *   La vue affiche le formulaire.
    *   Si basé sur une PO, les items de la PO sont listés, affichant produit, unité commandée, quantité commandée, déjà reçue, en attente. L'unité est généralement fixe (celle de la PO).
    *   Des champs permettent de saisir `quantity_received` pour chaque item de la PO. L'unité de réception est implicitement celle de la ligne de PO.
    *   Si livraison directe, un mécanisme (similaire à la création de PO) permet d'ajouter des produits, de sélectionner leur unité de réception (via JS et `$productUnitsMap`), et de saisir la quantité.

5.  **Utilisateur -> Navigateur Web (Formulaire) :**
    *   Entre date de livraison, quantités reçues, sélectionne unité de réception pour items manuels, notes.
    *   Clique sur "Enregistrer Réception".
    *   Requête POST (`index.php?url=delivery/store`) avec données de livraison et tableau `items` (chaque item avec `product_id`, `unit_id`, `quantity_received`, `purchase_order_item_id` si applicable).

6.  **Navigateur Web -> Serveur Web (Routeur) :**
    *   Le Routeur appelle `DeliveryController::store()`.

7.  **Routeur -> `DeliveryController::store()` :**
    *   Récupère et valide les données POST.
        *   Pour chaque item : valide `unit_id` (surtout pour items manuels) avec `ProductModel->isUnitValidForProduct()`.
        *   Si lié à une PO, valide que `quantity_received` ne dépasse pas `quantity_pending` pour l'unité de la PO.
        *   Si validation échoue : Recharge la vue `create.php` avec erreurs et données.
    *   Si validation réussit : Appelle `DeliveryModel->createDelivery($data, $itemsData)`.

8.  **`DeliveryController` -> `DeliveryModel::createDelivery($data, $itemsData)` :**
    *   Le modèle `DeliveryModel.php` commence une transaction PDO.
    *   **Insertion de l'en-tête de la livraison `deliveries`.** Récupère `$deliveryId`.
    *   **Pour chaque item dans `$itemsData` :**
        *   **Insertion de la ligne de livraison `delivery_items`** (incluant `$deliveryId`, `product_id`, `unit_id`, `quantity_received`, `purchase_order_item_id`). Récupère `$deliveryItemId`.
        *   **Mise à jour du stock du produit :**
            *   Appelle `ProductModel->updateStock($productId, 'in_delivery', (float)$item['quantity_received'], (int)$item['unit_id'], $deliveryItemId, 'delivery_items', $notes)`.
            *   `ProductModel->updateStock()` gère la conversion en unité de base et la création du mouvement dans `stock_movements` (avec `original_unit_id`, `original_quantity`).
            *   Si `updateStock` échoue, `createDelivery` fait un rollback.
    *   **Mise à jour du statut de la PO (si applicable) :**
        *   Recalcule le statut de la PO (`pending`, `partially_received`, `received`) en comparant les quantités totales commandées (converties en unité de base si nécessaire pour comparer avec les `delivery_items`) avec les quantités totales reçues pour cette PO (aussi converties en unité de base). Cette partie nécessite une logique de conversion si les unités de PO et de réception peuvent différer et que la comparaison doit être précise. Pour l'instant, on assume que la comparaison se fait sur les quantités exprimées dans leurs unités respectives si elles sont identiques, ou que les `pendingPoItems` sont déjà en unité de PO.
        *   Appelle `PurchaseOrderModel->updateStatus()`.
    *   Si tout réussit : Commit la transaction.
    *   Retourne `$deliveryId`.

9.  **`DeliveryModel` -> `Database` / `ProductModel` / `PurchaseOrderModel` (appels multiples) :**
    *   Exécutions des requêtes et logiques métier.

10. **Modèles -> `DeliveryModel` :**
    *   Résultats.

11. **`DeliveryModel` -> `DeliveryController` :**
    *   Retourne `$deliveryId` ou `false`.

12. **`DeliveryController::store()` (fin) :**
    *   Si succès : Redirection vers `delivery/show/$deliveryId`.
    *   Si échec : Recharge la vue `create.php` avec erreur.

13. **Navigateur Web :**
    *   Suit la redirection ou affiche le formulaire avec erreurs.

**Fin de la Séquence.**
