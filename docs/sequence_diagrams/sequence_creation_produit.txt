**Diagramme de Séquence : Création d'un Produit**

**Acteurs :** Utilisateur, Navigateur Web, Serveur Web (PHP)

**Composants :**
*   Navigateur Web
*   Routeur (`public/index.php`)
*   `ProductsController.php`
*   `ProductModel.php`
*   `ProductCategoryModel.php` (pour lister les catégories)
*   `UnitModel.php` (pour lister les unités)
*   `StockMovementModel.php`
*   `Database.php` (Classe Core)
*   Base de Données (PostgreSQL)
*   Vue (`products/create.php`, `products/show.php`, `layouts/main.php`)

**Séquence :**

1.  **Utilisateur -> Navigateur Web :**
    *   Clique sur "Ajouter Produit".
    *   Requête GET (ex: `index.php?url=products/create`).

2.  **Navigateur Web -> Serveur Web (Routeur) :**
    *   Le Routeur appelle `ProductsController::create()`.

3.  **Routeur -> `ProductsController::create()` :**
    *   `ProductsController` charge `ProductCategoryModel` et `UnitModel`.
    *   Appelle `ProductCategoryModel->getAll()` pour obtenir la liste des catégories.
    *   Appelle `UnitModel->getAll()` pour obtenir la liste des unités (pour l'unité de base et les unités alternatives).
    *   Appelle `renderView('products/create', $data)` avec les catégories, les unités, etc.

4.  **`ProductsController` -> Vue (`products/create.php`) :**
    *   La vue affiche le formulaire avec des `<select>` pour la catégorie et l'unité de base, et une section pour les unités alternatives.

5.  **Utilisateur -> Navigateur Web :**
    *   Remplit les champs du formulaire (nom, description, catégorie, unité de base, prix, stock initial, etc.).
    *   Ajoute potentiellement des unités alternatives avec leurs facteurs de conversion.
    *   Clique sur "Ajouter Produit".
    *   Le navigateur envoie une requête POST (`index.php?url=products/store`) avec les données du formulaire, y compris `category_id`, `base_unit_id`, et un tableau `alternative_units` si fourni.

6.  **Navigateur Web -> Serveur Web (Routeur) :**
    *   Le Routeur appelle `ProductsController::store()`.

7.  **Routeur -> `ProductsController::store()` :**
    *   Récupère les données POST.
    *   Valide les données:
        *   Nom, `base_unit_id` sont requis.
        *   `category_id` (si fourni) doit exister.
        *   `base_unit_id` doit exister.
        *   Les `unit_id` des unités alternatives (si fournies) doivent exister et les facteurs de conversion doivent être numériques.
        *   Si validation échoue : Recharge la vue `products/create.php` avec erreurs, données soumises, listes de catégories/unités.
    *   Si validation réussit : Appelle `ProductModel->create($data)`. `$data` inclut `category_id`, `base_unit_id`, etc.

8.  **`ProductsController` -> `ProductModel::create($data)` :**
    *   Le modèle `ProductModel.php` commence une transaction PDO.
    *   Construit une requête SQL INSERT pour `products` avec les champs validés.
    *   Exécute la requête via `Database->insert()`. Récupère `$productId`.
    *   Si l'insertion du produit réussit :
        *   Appelle `$this->addUnit($productId, $data['base_unit_id'], 1.0, true)` pour ajouter l'unité de base à `product_units`. (Le `true` est un drapeau interne).
        *   Si échec d'ajout de l'unité de base, rollback et retourne `false`.
    *   Si tout réussit jusqu'ici, commit la transaction PDO.
    *   Retourne `$productId`.

9.  **`ProductModel` -> `Database` (Appels multiples potentiels) :**
    *   Exécute INSERT pour `products`.
    *   Exécute INSERT pour `product_units` (pour l'unité de base).

10. **`Database` -> `ProductModel` :**
    *   Résultats des insertions.

11. **`ProductModel` -> `ProductsController` :**
    *   Retourne `$productId` (si succès) ou `false` (si échec).

12. **`ProductsController::store()` (suite) :**
    *   Si `$productId` est valide :
        *   **Gestion des Unités Alternatives :** Si `$_POST['alternative_units']` est fourni et est un tableau :
            *   Pour chaque unité alternative (`altUnit`) :
                *   Valider `altUnit['unit_id']` et `altUnit['conversion_factor']`.
                *   S'assurer que `altUnit['unit_id']` n'est pas égal à `base_unit_id`.
                *   Appeler `ProductModel->addUnit($productId, $altUnit['unit_id'], $altUnit['conversion_factor'])`.
                *   Si `addUnit` échoue pour une unité alternative, enregistrer l'erreur (mais ne pas nécessairement annuler toute la création du produit à ce stade, ou le faire si c'est critique).
        *   **Gestion du Stock Initial :** Si un stock initial (`$data['quantity_in_stock']`) > 0 a été fourni :
            *   `ProductsController` instancie `StockMovementModel`.
            *   Appelle `StockMovementModel->createMovement()` avec :
                *   `product_id = $productId`
                *   `type = 'initial_stock'`
                *   `quantity_in_transaction_unit = $data['quantity_in_stock']`
                *   `transaction_unit_id = $data['base_unit_id']` (le stock initial est dans l'unité de base)
                *   `notes = 'Stock initial lors de la création du produit.'`
            *   (Le `ProductModel->create()` a déjà mis à jour `products.quantity_in_stock`.)
    *   Si tout a réussi (ou partiellement pour les alternatives) :
        *   Redirection vers `products/show/$productId` avec message de succès.
    *   Si la création initiale du produit dans `ProductModel->create()` a échoué :
        *   Recharge la vue `products/create.php` avec un message d'erreur général et les données/listes.

13. **Navigateur Web :**
    *   Suit la redirection et affiche le produit créé ou le formulaire avec erreurs.

**Fin de la Séquence.**
